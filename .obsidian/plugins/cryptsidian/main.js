/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var path = require('path');
var fs = require('fs');
var crypto = require('crypto');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var crypto__namespace = /*#__PURE__*/_interopNamespace(crypto);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/* Cryptsidian
* By: triumphantomato
* https://github.com/triumphantomato
*/ 

/*
* crypto primitives
*/
const ALGORITHM = 'aes-256-ctr';
const SALT = Buffer.alloc(32, '3170ebab43b9ccaaacbbb0ee72285a21c39fa324315db3ddcc11da1e3ff816e5', 'hex');
const KEY_LENGTH = 32; // length in bytes

/*
* global variables
*/
let secretKey; //will be derived from user input later 


/**
************************
************************
* API Functions
************************
************************
**/

/* all of these are implemented in the main.ts file, in onOpen() on class CryptoModal

* Registering Cryptsidian with the Obsidian Plugin API
* Prompting the user to enter their password for encryption/decryption. 
* Retrieving the path to the user's Obsidian vault
*/


/**
************************
************************
* Backend Functions
************************
************************
**/


/**
************************
* Backend: passwords
************************
**/


/**
* Takes a user-supplied string and checks for safety.
* @param {string} input - user supplied string
* @return {false|string} - false when input fails checks or string of user input if it passes.
**/
function stringSanitizer( input ){
	if (typeof(input) !== 'string'){
		throw new Error("Password must be a string, received " + typeof(input) + " instead\n");
	}

	//deal with accents - normalize Unicode
	input = input.normalize('NFC'); 

	//validate entropy
	if (hasEnoughEntropy(input)){
		return input;
	}

	return false;
}

/**
* Takes a string and checks for sufficient entropy. 
* If a user's password has all character types (number, lower and uppercase, special chars), it will require 13 characters minimum at level=80.
* @param {string} input - input string
* @param {number} [level = 80] - entropy level in bits. 64 - okay but iffy, 80 - okay, 112 - recommended, 256 - probably quantum secure. Take these guidelines with a grain of salt and consult a cryptographer for your application.
* @return {bool} judgment - true if sufficient, false if not
**/
function hasEnoughEntropy( input, level=80 ){
	if (level < 64){
		throw new Error('Function hasEnoughEntropy() called with < 64 bits of entropy. This is unsafe, aborting.\n');
	}
	
	let charspace = 0;
	let minlength = Math.ceil(level/Math.log2(10+26+26+32));

	if (level >= 64){

		//test entropy (via minlength)
		if (input.length < minlength){
			throw {
				name: "PasswordError",
				message: "Your password is not long enough. It must be " + minlength + " characters or longer.\n"
			}
		}

		//test entropy (via explicit entropy calculation)
		if (/\d+/g.test(input)) charspace += 10; //digits in charspace
		if (/[a-z]/g.test(input)) charspace += 26; //lowercase in charspace
		if (/[A-Z]/g.test(input)) charspace += 26; //uppercase in charspace
		if (/[`~!@#$%^&*()-=_+\[\]{};':"\\|,.<>\/?]/g.test(input)) charspace += 32; //special chars in charspace
		
		let entropy = input.length * Math.log2(charspace);

		if (entropy < level){
			throw {
				name: "PasswordError",
				message: "Your password is not strong enough. Try adding different kinds of characters, like numbers, special characters, or uppercase letters.\n"
			}
		}

		else if (entropy >= level){
			return true;
		}

		return false;

	}

	return false;
}


/**
************************
* Backend: keys
************************
**/


/**
* Takes a user password and sets the secretKey global variable by calling keyDeriver(password). 
* Is the isolation boundary between backend and frontend.
* @param {string} password - user password to derive encryption key from
* @returns <void>
**/
function setUserSecretKey( password ){
	secretKey = Buffer.alloc(KEY_LENGTH); //zero-fills secretKey to be a buffer of length KEY_LENGTH
	secretKey = keyDeriver(password);
	return;
}

/**
* Takes an input string and returns a secret key of length key_length (default is value of constant KEY_LENGTH).
* @param {string} input
* @param {number} [key_length = KEY_LENGTH]
* @return {Buffer} secretKey
**/
function keyDeriver( input, key_length=KEY_LENGTH ){
	if(input == null || typeof(input) !== 'string'){
		throw new Error("Function keyDeriver received bad input. Expected a non-null string.");
	}

	let password = stringSanitizer(input);
	if (password){
		secretKey = crypto__namespace.scryptSync(password, SALT, KEY_LENGTH);
		return secretKey;
	}
}

/**
* Checks to ensure secretKey is correctly set and then returns it. Accessing secretKey outside of this function is unsafe.
* @returns {Buffer} secretKey
**/

function getSecretKey( ){
	if (secretKey == null){ // (== null) checks null and undefined
		throw {
				name: "KeyError",
				message: "secretKey is null or undefined. Uh-oh.\n"
			}
	}

	if (secretKey.length !== KEY_LENGTH){
		throw {
			name: "KeyError",
			message: "secretKey is not the right length. Got: " + secretKey.length + " bytes, but expected: " + KEY_LENGTH + " bytes"
		}
	}

	return secretKey;
}


/**
**************************
* Backend: encrypt/decrypt
**************************
**/


/**
* Overwrites an encrypted version of the file to disk
* @param {string} file_path - location of file to encrypt
* @returns <void>
**/
function encryptFile( file_path ){
	//get data and file descriptor
	let data = getFileBuffer(file_path);
	let fd = openFile(file_path);
	
	//generate IV
	let iv = crypto__namespace.randomBytes(16);

	//validate secretKey not empty
	let key = getSecretKey();

	//make a ciphertext
	const cipher = crypto__namespace.createCipheriv(ALGORITHM, key, iv);
	const encrypted_data = Buffer.concat([cipher.update(data), cipher.final()]); 
	//cipher.final() not necessary for aes-256-ctr but this construciton should also
	//work with other algorithms
		
	//prepend IV and write encrypted data back to file
	fs__namespace.writeSync(fd, iv, 0, iv.length, 0); 
	fs__namespace.writeSync(fd, encrypted_data, 0, encrypted_data.length, iv.length);

	//cleanup
	fs__namespace.close(fd, (err) => {
		if (err){
			console.error("failed to close file descriptor when attempting to encrypt file: \n" + file_path + "\n in function encryptFile()\n");
			throw new Error(err);
		}
	});

}

/**
* Decrypts a file and writes it to disk, in place
* @param {string} file_path - file to decrypt
* @returns <void>
**/ 
function decryptFile( file_path ){

	//get this to calculate cipher_data_length later
	let stats = fs__namespace.statSync(file_path); //must be done before opening the fd or it errors

	//get secretKey
	let key = getSecretKey();

	//get file descriptor
	let fd = openFile(file_path);

	//calculate cipher_data_length
	let cipher_data_length = (stats.size - 16); //in bytes, minus the 16-byte IV

	//we'll walk through the file to extract IV and then content instead of using getFileBuffer() helper function
	//read first 16 bytes for the IV
	let iv = Buffer.alloc(16);
	try{
		fs__namespace.readSync(fd, iv, 0, 16, null); //should advance file position to 16 bytes in
	}
	catch (err){
		console.error("Error using fs.readSync(fd, iv, 0, 16, null) to get the IV back");
		throw new Error(err);
	}

	//read the rest for the data
	let cipher_data = Buffer.alloc(cipher_data_length);
	fs__namespace.readSync(fd, cipher_data, 0, cipher_data_length, null); //should start the read from 16 bytes in

	//now make a decipher object and decrypt the file
	const decipher = crypto__namespace.createDecipheriv(ALGORITHM, key, iv);
	const decrypted_data = Buffer.concat([decipher.update(cipher_data), decipher.final()]);

	//write the cleartext data back to file
	fs__namespace.writeSync(fd, decrypted_data, 0, decrypted_data.length, 0);

	//truncate the remaining crypto bytes from the overwritten file
	try{
		fs__namespace.ftruncateSync(fd, cipher_data_length); 
	}
	catch (err){
		console.error("Error truncating file after decryption in decryptFile(), for file: \n" + file_path);
		throw new Error(err);
	}

	//cleanup
	fs__namespace.close(fd, (err) => {
		if (err){
			console.error("failed to close file descriptor when attempting to decrypt file: \n" + file_path + "\n in function decryptFile()\n");
			throw new Error(err);
		}
	});

}


/**
************************
* Backend: files
************************
**/

/**
* Returns an fd or error for a file.
* @param {string} file_path
* @returns {number} fd
**/
function openFile( file_path ){
	let fd;
	try{
		fd = fs__namespace.openSync(file_path, 'r+');
	}
	catch (err){
		throw new Error(err);
	}

	return fd;
}

/** 
* Returns the contents of a file as a buffer.
* @param {string} file_path - a single file path to read
* @return {Buffer} buf - buffer of an individual file
**/
function getFileBuffer( file_path ){
	file_path = path__namespace.normalize(file_path);
	let buf;
	try{
		buf = fs__namespace.readFileSync(file_path);
	}
	catch (err){
		console.error("failed calling getFileBuffer() on file_path: " + file_path);
		throw new Error(err);
	}
	return buf;
}

/**
* Takes an array of filepaths and encrypts or decrypts them depending on operation.
* @param {Array}<string> file_array
* @param {string} operation
**/
function fileProcessor( file_array, operation ){
	if (operation === 'ENCRYPT'){
		for (const file of file_array){
			encryptFile(file);
		}
		return;
	}
	if (operation === 'DECRYPT'){
		for (const file of file_array){
			decryptFile(file);
		}
		return;
	}
	else throw new Error("fileProcessor(file_array, operation) called with invalid operation argument. \n Got " + operation + ". Must be ENCRYPT or DECRYPT.");
}

/**
* Returns array of all files with absolute paths in Vault dir and all sub-dirs
* @param {string} vault - absolute path to the user's Obsidian vault
* @return {Array}<string> vault_files
**/
function getVaultFiles( vault ){
	vault = path__namespace.normalize(vault);

	let vault_files = [];
	let files = [];

	try {
		files = fs__namespace.readdirSync(vault, {withFileTypes: true});
	} 
	catch (err) {
		console.error('failed calling fsreaddirSync(vault, {withFileTypes: true} on this directory: \'' + vault + '\'\n');
		throw new Error(err);
	}
	
	for (const file of files){
		if (file.name[0] === '.') continue; //skip dotfiles -- do i need to change this to be Windows compatible?

		if (file.isFile()){
			let absolutePath = path__namespace.resolve(vault, file.name);
			vault_files.push(absolutePath);
		
		}

		else if (file.isDirectory()){
			vault_files.push(...getVaultFiles(path__namespace.resolve(vault, file.name))); 
			//... is spread syntax unpacking the returned vault_files array from the recursed call
		}
	
	}

	return vault_files;

	//todo: make vault_files a TS array of only strings

}

const DEFAULT_SETTINGS = {
    mySetting: 'default'
};
class MyPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('loading plugin');
            yield this.loadSettings();
            this.addCommand({
                id: 'open-encrypt-modal',
                name: 'Open Encrypt Modal',
                checkCallback: (checking) => {
                    let leaf = this.app.workspace.activeLeaf;
                    if (leaf) {
                        if (!checking) {
                            new CryptoModal(this.app, 'Encrypt').open();
                        }
                        return true;
                    }
                    return false;
                }
            });
            this.addCommand({
                id: 'open-decrypt-modal',
                name: 'Open Decrypt Modal',
                checkCallback: (checking) => {
                    let leaf = this.app.workspace.activeLeaf;
                    if (leaf) {
                        if (!checking) {
                            new CryptoModal(this.app, 'Decrypt').open();
                        }
                        return true;
                    }
                    return false;
                }
            });
        });
    }
    onunload() {
        console.log('unloading plugin');
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
class CryptoModal extends obsidian.Modal {
    constructor(app, operation) {
        super(app);
        this.password = null;
        this.operation = null;
        this.operation = operation;
    }
    onOpen() {
        // get vault dir
        let vault_dir = this.app.vault.adapter.getBasePath();
        //initiailze an empty DOM object to hold our modal
        let { contentEl } = this;
        contentEl.empty();
        //title - to let the user know which mode (encrypt/decrypt) they're in
        const titleEl = contentEl.createDiv();
        titleEl.style.fontWeight = 'bold';
        titleEl.style.marginBottom = '1em';
        titleEl.setText(`${this.operation}`);
        //notice - to let the user know which folder will be encrypted/decrypted
        const folderNotice = contentEl.createDiv();
        folderNotice.style.marginBottom = '1em';
        folderNotice.setText('This operation will apply to all files and folders in: ' + vault_dir);
        folderNotice.style.color = 'red';
        //notice - tell user not to open encrpyted files
        const corrputionNotice = contentEl.createDiv();
        corrputionNotice.style.marginBottom = '1.5em';
        corrputionNotice.setText('Do not open files with Obsidian after encrypting - they can become corrupted and irrecoverable. Always use the Decrypt command prior to re-opening files!');
        corrputionNotice.style.color = 'red';
        //make a div for user's pw input
        const inputPwContainerEl = contentEl.createDiv();
        const pwInputEl = inputPwContainerEl.createEl('input', { type: 'password', value: '' });
        pwInputEl.placeholder = 'Please enter your password';
        pwInputEl.style.width = '70%';
        pwInputEl.focus();
        //make a div for pw confirmation
        const confirmPwContainerEl = contentEl.createDiv();
        confirmPwContainerEl.style.marginTop = '1em';
        const pwConfirmEl = confirmPwContainerEl.createEl('input', { type: 'password', value: '' });
        pwConfirmEl.placeholder = 'Confirm your password';
        pwConfirmEl.style.width = '70%';
        //make a submit button for the crypto operation
        const confirmBtnEl = confirmPwContainerEl.createEl('button', { text: `${this.operation}` });
        confirmBtnEl.style.marginLeft = '1em';
        //message modal - to fire if passwords don't match
        const messageMatchEl = contentEl.createDiv();
        messageMatchEl.style.marginTop = '1em';
        messageMatchEl.style.color = 'red';
        messageMatchEl.setText('Passwords must match');
        messageMatchEl.hide();
        //message modal - to fire if either input is empty
        const messageEmptyEl = contentEl.createDiv();
        messageEmptyEl.style.marginTop = '1em';
        messageEmptyEl.style.color = 'red';
        messageEmptyEl.setText('Please enter your password in both boxes.');
        messageEmptyEl.hide();
        //message modal - to fire with cryptoSource.stringSanitizer() error message, if any
        const messageEl = contentEl.createDiv();
        messageEl.style.color = 'red';
        messageEl.style.marginTop = '1em';
        messageEl.hide();
        // check the input
        const pwChecker = (ev) => {
            ev.preventDefault();
            let good_to_go = false;
            // is either input field empty?
            if (pwInputEl.value == '' || pwInputEl.value == null || pwConfirmEl.value == '' || pwConfirmEl.value == null) {
                good_to_go = false;
                messageEmptyEl.show();
            }
            if (pwInputEl.value !== '' && pwInputEl.value !== null && pwConfirmEl.value !== '' && pwConfirmEl.value !== null) {
                good_to_go = true;
                messageEmptyEl.hide();
            }
            // do both password inputs match?
            if (pwInputEl.value !== pwConfirmEl.value) {
                good_to_go = false;
                messageMatchEl.show();
            }
            if (pwInputEl.value === pwConfirmEl.value) {
                good_to_go = true;
                messageMatchEl.hide();
            }
            // is the user's password strong enough for crypto?
            if (good_to_go) {
                try {
                    messageEl.hide();
                    good_to_go = Boolean(stringSanitizer(pwInputEl.value));
                    //true if user input had enough entropy, false otherwise
                }
                catch (error) {
                    good_to_go = false;
                    messageEl.setText(error.message);
                    messageEl.show();
                }
            }
            // if all checks pass, execute the crypto operation
            if (good_to_go) {
                this.password = pwConfirmEl.value;
                setUserSecretKey(this.password); //derive the secret key via scrypt from user's password
                // close open notes to prevent post-encryption access, which can corrupt files and make them irrecoverable
                const emptyLeaf = (leaf) => __awaiter(this, void 0, void 0, function* () {
                    leaf.setViewState({ type: 'empty' });
                });
                const closeLeaves = () => __awaiter(this, void 0, void 0, function* () {
                    let leaves = [];
                    this.app.workspace.iterateAllLeaves((leaf) => {
                        leaves.push(leaf);
                    });
                    for (const leaf of leaves) {
                        if (leaf.view instanceof obsidian.FileView) {
                            yield emptyLeaf(leaf);
                            leaf.detach();
                        }
                    }
                });
                const processFiles = () => __awaiter(this, void 0, void 0, function* () {
                    yield closeLeaves();
                    fileProcessor(files, this.operation.toUpperCase());
                });
                //run the encryption or decryption
                let files = getVaultFiles(vault_dir);
                processFiles();
                this.close();
            }
        };
        //register the button's event handler
        confirmBtnEl.addEventListener('click', pwChecker);
        //allow enter to submit
        const enterSubmits = function (ev, value) {
            if ((ev.code === 'Enter' || ev.code === 'NumpadEnter')
                && value.length > 0
                && confirmBtnEl.disabled === false) {
                ev.preventDefault();
                confirmBtnEl.click();
            }
        };
        pwInputEl.addEventListener('keypress', function (ev) { enterSubmits(ev, pwInputEl.value); });
        pwConfirmEl.addEventListener('keypress', function (ev) { enterSubmits(ev, pwInputEl.value); });
    }
    onClose() {
        let { contentEl } = this;
        contentEl.empty();
    }
}

module.exports = MyPlugin;


/* nosourcemap */